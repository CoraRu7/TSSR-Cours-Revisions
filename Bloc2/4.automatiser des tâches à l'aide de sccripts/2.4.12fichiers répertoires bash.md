# **Gestion des fichiers et répertoires sous Shell Bash (Sécurité et bonnes pratiques)**

## **Objectif**

Apprendre à gérer fichiers et répertoires sous Bash tout en respectant les bonnes pratiques de sécurité pour éviter les attaques Web Shell et les erreurs de scripts.

---

## **Concepts clés**

### **1. Sécurité contre les attaques Web Shell**

* **Web Shell** : script malveillant déployé sur un serveur pour exécuter des commandes à distance (PHP, ASP, Python, Bash).
* **Risques** : téléchargement, suppression, exécution de fichiers, élévation de privilèges.
* **Mesures préventives** :

  1. Mettre à jour OS et applications régulièrement.
  2. Appliquer le **principe du moindre privilège** pour les utilisateurs et répertoires web.
  3. Isoler le serveur Web (DMZ) et monitorer le trafic.
  4. Configurer le serveur Web :

     * Bloquer services inutiles
     * Désactiver listing de répertoire
     * Protéger panneau de gestion
     * Utiliser mots de passe forts
  5. Valider strictement les entrées utilisateur.
  6. Analyser vulnérabilités et déployer firewall ou proxy inverse.
* **Bonne pratique dans les scripts** :

  * Toujours utiliser le chemin complet des commandes (`/bin/ls` au lieu de `ls`) pour éviter les chevaux de Troie.
  * Ne jamais inclure `.` dans le `PATH`.
  * Ne pas stocker de mots de passe en clair dans les scripts.

---

### **2. Bonnes pratiques dans un script Bash**

* **Modularité** : utiliser des fonctions pour rendre le code réutilisable et lisible.

```bash
process_file(){
  local -r input_file="$1"; shift
  local -r output_file="$1"; shift
}
```

* **Documentation** : commenter les fonctions et variables.

* **Variables** :

  * Déclarer le type si nécessaire (`integer`).
  * Citer toutes les variables pour éviter les erreurs avec espaces ou caractères spéciaux.
  * Utiliser `$@` plutôt que `$*` pour gérer les arguments.
  * Majuscules uniquement pour les variables d’environnement.

* **Manipulation de fichiers** :

  * Préférer les Shell intégrés aux programmes externes pour opérations simples.
  * Éviter `cat` inutilement :

```bash
# Mauvais
cat file | command
# Correct
command < file
```

* Globbing (`*`, `?`, `[]`) pour gérer les fichiers efficacement.

* Gérer correctement les valeurs nulles ou espaces : `find -print0 | xargs -0`.

* Utiliser `$(command)` plutôt que les backticks `` `command` ``.

* Préférer la **substitution de processus** `<(command)` pour éviter les fichiers temporaires.

* Utiliser `mktemp` pour créer des fichiers ou répertoires temporaires en toute sécurité.

* **Conditions et tests** :

  * Préférer `[[ ... ]]` pour les tests, `(( ... ))` pour arithmétique.
  * Vérifier directement la réussite d’une commande dans `if` plutôt que `$?`.

* **Contrôle d’erreur global** :

```bash
set -e  # quitte le script si une commande échoue
```

* **Pipes** : éviter les chaînes de pipes inutiles, réduire la surcharge :

```bash
# Mauvais
grep pattern file | awk '{print $1}'
# Correct
awk '/pattern/{print $1}' file
```

---

### **3. Validation des entrées utilisateur**

* Ne jamais faire confiance aux entrées :

```bash
echo -n "Quel dossier ouvrir ? "
read name
/bin/ls -l "$name"  # sécurisation
```

* Éviter `eval` et backticks sur les entrées.
* Contrôler les caractères : n’autoriser que alphanumériques ou signes de ponctuation sûrs.

---

### **III) Essentiel**

* Éviter de stocker les mots de passe dans les scripts.
* Valider et nettoyer toutes les entrées utilisateur pour éviter l’exécution de commandes non désirées.
* Utiliser des fonctions, des variables sécurisées, et citer les noms de fichiers.
* Préférer les commandes internes au Shell et les substitutions sécurisées (`$(...)`, `<(...)`, `mktemp`).
* Toujours activer `set -e` pour interrompre le script en cas d’erreur critique.

---